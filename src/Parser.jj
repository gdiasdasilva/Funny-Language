PARSER_BEGIN(Parser)

import ast.*;
import compiler.*;
public class Parser {
  
  /** Main entry point. */
  public static void main(String args[]) {
    Parser parser = new Parser(System.in);
    ASTNode exp;
    while (true) {
	    try {
			/*exp = new ASTCond(
				new ASTEq(new ASTPlus(new ASTNum(3), new ASTNum(3)), new ASTDiv(new ASTNum(12), new ASTPlus(new ASTNum(-1), new ASTNum(3)))),
				new ASTPlus(new ASTNum(1), new ASTNum(2)),
				new ASTMul(new ASTNum(2), new ASTNum(7))
			);*/
		    exp = parser.Start();
		    System.out.println(exp.eval());
		    /*CodeBlock cb = new CodeBlockClass();
		    exp.compile(cb);
		    for (String s : cb.getStringList())		    {
		      System.out.println(s);
		    }*/
	    }
	    catch (ParseException e) {
	      System.out.println ("Syntax Error!");
	      parser.ReInit(System.in);
	    }
    }
  }

}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
}

TOKEN :
{
  < Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
  |
  < Num: (["0"-"9"]) + >
  |
  < LPAR : "(" >
  |
  < RPAR : ")" >
  |
  < ADD_OP : "+" >
  |
  < MINUS : "-" >
  | 
  < MUL_OP : "*" >
  |
  < DIV_OP : "/" >
  |
  < EQ : "==" >
  |
  < IF_TOK : "?" >
  |
  < ELSE_TOK : ":" >
  |
  < GREQ : ">=" >
  |
  < LSEQ : "<=" >
  |
  < NEQ : "!=" >
  |
  < AND : "&&" >
  |
  < OR : "||" >
  |
  < NOT: "!" >
  |
  < EL: "\n" >
}

ASTNode Start():
{ ASTNode t; }
{
  	t=LogExp() <EL>
  	{ return t; } 
}

ASTNode LogExp():{ ASTNode tl1, tl2; Token op; }{
  tl1 = LogT() ( ( op = < OR >) tl2 = LogT()
  { tl1 = new ASTOr(tl1, tl2); }
  )*
  { return tl1; }}

ASTNode LogT():
{ ASTNode e1, e2; Token op; }
{	e1 = CmpExp() ( (op = < AND > ) e2 = CmpExp()
	{ e1 = new ASTAnd(e1, e2); }
	)*
	{ return e1; }
}

ASTNode CmpExp():
{ ASTNode e1, e2; Token op; }
{
	e1 = CondExp() ( (op = < EQ > | op = < GREQ > | op = < LSEQ > | op = < NEQ >) e2 = CondExp()
	{
	  if(op.kind == EQ)
	  {
	    e1 = new ASTEq(e1, e2);	  }
	  else if(op.kind == GREQ)
	  {
	    e1 = new ASTGreq(e1, e2);	  }
	  else if(op.kind == LSEQ)
	  {
	    e1 = new ASTLseq(e1, e2);	  }
	  else
	  {
	    e1 = new ASTNeq(e1, e2);	  }
	}
	)*
	{ return e1; }		
}

ASTNode CondExp():
{ASTNode e1, e2, e3;}
{
	(	  e1 = Exp() ( < IF_TOK > e2 = Exp() < ELSE_TOK > e3 = Exp() { return new ASTCond(e1, e2, e3); } )?
    )
    { return e1; }
}

ASTNode Exp():
{ Token op;
  ASTNode t1, t2; }
{
      t1 = Term() ( ( op=<ADD_OP> | op=<MINUS> ) t2 = Term() 
	  {                 
           if ( op.kind == ADD_OP )
               t1 = new ASTPlus(t1,t2);
           else
               t1 = new ASTSub(t1,t2);      }
      )*
 	{ return t1; }
}

ASTNode Term():
{ Token op;
  ASTNode f1, f2; }
{
 	f1 = Factor() ( (op = <MUL_OP> | op = < DIV_OP >) f2 = Factor()
 	{
 	  if (op.kind == MUL_OP)
 	    f1 = new ASTMul(f1, f2);
 	  else
 	    f1 = new ASTDiv(f1, f2); 	}
 	)*
 	{ return f1; }	
}

ASTNode Factor():
{ Token n; ASTNode f;
}
{
	(	   n = <Num> { f = new ASTNum(Integer.parseInt(n.image)); } | <LPAR> ( f = LogExp() ) <RPAR> | < MINUS > f = Factor()	   { f = new ASTUnMinus(f); }
	)
	{ return f; }
}

PARSER_BEGIN(Parser)

package parser;

import ast.*;
import semantics.*;

public class Parser
{
	public static final Env env = new IEnv();
}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
}

TOKEN :
{
< Num: (["0"-"9"]) + >
| < BOOL_LIT: "true" | "false" >
| < LPAR : "(" >
| < RPAR : ")" >
| < ADD_OP : "+" >
| < MINUS : "-" >
| < MUL_OP : "*" >
| < DIV_OP : "/" >
| < EQ : "==" >
| < IF_TOK : "?" >
| < ELSE_TOK : ":" >
| < GR: ">" >
| < GREQ : ">=" >
| < LS: "<" >
| < LSEQ : "<=" >
| < NEQ : "!=" >
| < AND : "&&" >
| < OR : "||" >
| < NOT: "!" >
| < EL: "\n" >
| < DECL: "decl" >
| < ASSOC: "=" >
| < IN: "in" >
| < END: "end" >
| < Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
}

ASTNode start():
{ ASTNode t; }
{
  	t = Decl() < EL >
  	{ return t; } 
}

ASTNode Decl():
{ ASTNode e1, e2, e3; Token var;}
{
  < DECL > (var = < Id > < ASSOC > e2 = Decl())+ < IN > e3 = Decl() < END > { return new ASTDecl(var.image, e2, e3); } |
  e1 = CondExp() { return e1; }
 
}

ASTNode CondExp():
{ ASTNode e1, e2, e3; }
{
	(	  e1 = LogExp() ( < IF_TOK > e2 = CondExp() < ELSE_TOK > e3 = CondExp() { return new ASTCond(e1, e2, e3); } )?
    )
    { return e1; }
}
ASTNode LogExp():{ ASTNode tl1, tl2; Token op; }
{
  tl1 = LogT() ( ( op = < OR >) tl2 = LogT()
  { tl1 = new ASTOr(tl1, tl2); }
  )*  { return tl1; }
}

ASTNode LogT():
{ ASTNode e1, e2; Token op; }{
	e1 = CmpExp0() ( (op = < AND > ) e2 = CmpExp0()
	{ e1 = new ASTAnd(e1, e2); }
	)*
	{ return e1; }
}

ASTNode CmpExp0():
{ ASTNode e1, e2; Token op; }
{
  e1 = CmpExp() ( ( op = < EQ > | op = < NEQ > ) e2 = CmpExp()
  {
    if (op.kind == EQ)
      e1 = new ASTEq(e1, e2);
    else
      e1 = new ASTNeq(e1, e2);  }
  )*
  { return e1; }
}

ASTNode CmpExp():
{ ASTNode e1, e2; Token op; }
{
	e1 = Exp() ( (op = < GREQ > | op = < LSEQ > | op = < GR > | op = < LS >) e2 = Exp()
	{
	  if (op.kind == GREQ)
	  {	    e1 = new ASTGreq(e1, e2);
	  }
	  else if (op.kind == LSEQ)
	  {	    e1 = new ASTLseq(e1, e2);
	  }
	  else if (op.kind == GR)
	  {	    e1 = new ASTGr(e1, e2);
	  }
	  else
	  {
	    e1 = new ASTLs(e1, e2);	  }
	}
	)*
	{ return e1; }
}


ASTNode Exp():
{ Token op;
  ASTNode t1, t2; }
{
      t1 = Term() ( ( op=<ADD_OP> | op=<MINUS> ) t2 = Term() 
	  {                 
           if ( op.kind == ADD_OP )
               t1 = new ASTPlus(t1,t2);
           else
               t1 = new ASTSub(t1,t2);      }
      )*
 	{ return t1; }
}

ASTNode Term():
{ Token op;
  ASTNode f1, f2; }
{
 	f1 = Factor() ( (op = <MUL_OP> | op = < DIV_OP >) f2 = Factor()
 	{
 	  if (op.kind == MUL_OP)
 	    f1 = new ASTMul(f1, f2);
 	  else
 	    f1 = new ASTDiv(f1, f2); 	}
 	)*
 	{ return f1; }	
}

ASTNode Factor():
{ Token n; ASTNode f;
}
{
	(	   n = <Num> { f = new ASTNum(IValue.fromInteger(Integer.parseInt(n.image))); } |
	   n = < BOOL_LIT > { f = new ASTTruth(new BValue(Boolean.parseBoolean(n.image))); } | 
	   <LPAR> ( f = Decl() ) <RPAR> |
	   < MINUS > f = Factor() { f = new ASTUnMinus(f); } |
	   < NOT > f = Factor() { f = new ASTNot(f); } |
	   n = < Id > { f = new ASTId(n.image); }
	)
	{ return f; }
}
